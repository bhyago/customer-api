"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgBaseRepository = void 0;
const common_1 = require("@nestjs/common");
const pg_format_1 = __importDefault(require("pg-format"));
const pg_database_service_1 = require("./pg-database.service");
let PgBaseRepository = class PgBaseRepository {
    constructor(pg) {
        this.pg = pg;
        this.CRUD = {
            find: async (where = {}, pool) => {
                const queryString = (0, pg_format_1.default)("SELECT * FROM %I", this.tableName());
                return await this.pg.runQuery(queryString, where, pool);
            },
            findOne: async (where, pool) => {
                const queryString = (0, pg_format_1.default)("SELECT * FROM %I", this.tableName());
                return await this.pg.runQuerySingle(queryString, where, pool);
            },
            create: async (data, pool) => {
                let _data = Object.assign({}, data);
                const columns = Object.keys(_data);
                const values = columns.map((col) => (0, pg_format_1.default)("%L", _data[col]));
                const queryString = (0, pg_format_1.default)("INSERT INTO %I (%I) VALUES (%s) RETURNING *", this.tableName(), columns, values.join(","));
                const result = await this.pg.runQuery(queryString, {}, pool);
                return result[0];
            },
            update: async (data, where, pool) => {
                let _data = Object.assign({}, data);
                const updates = [];
                for (let key in _data) {
                    const value = _data[key];
                    let opValue;
                    if (typeof value === "object" && value !== null) {
                        const opValueObj = value;
                        let operation;
                        if ("increment" in opValueObj &&
                            typeof opValueObj.increment === "number") {
                            operation = "+";
                            opValue = (0, pg_format_1.default)("%L", opValueObj.increment);
                        }
                        else if ("decrement" in opValueObj &&
                            typeof opValueObj.decrement === "number") {
                            operation = "-";
                            opValue = (0, pg_format_1.default)("%L", opValueObj.decrement);
                        }
                        else if ("multiply" in opValueObj &&
                            typeof opValueObj.multiply === "number") {
                            operation = "*";
                            opValue = (0, pg_format_1.default)("%L", opValueObj.multiply);
                        }
                        else if ("divide" in opValueObj &&
                            typeof opValueObj.divide === "number") {
                            operation = "/";
                            opValue = (0, pg_format_1.default)("%L", opValueObj.divide);
                        }
                        if (operation) {
                            updates.push((0, pg_format_1.default)("%I = %I %s %s", key, key, operation, opValue));
                            continue;
                        }
                    }
                    opValue = (0, pg_format_1.default)("%L", value);
                    updates.push((0, pg_format_1.default)("%I = %s", key, opValue));
                }
                const queryString = (0, pg_format_1.default)("UPDATE %I SET %s", this.tableName(), updates.join(", "));
                await this.pg.runQuery(queryString, where, pool);
            },
            delete: async (where, pool) => {
                const queryString = (0, pg_format_1.default)("DELETE FROM %I", this.tableName());
                await this.pg.runQuery(queryString, where, pool);
            },
            runTransaction: async (callback, advisoryLock) => {
                try {
                    return await this.pg.runTransaction(callback, advisoryLock);
                }
                catch (error) {
                    throw error;
                }
            },
        };
    }
};
exports.PgBaseRepository = PgBaseRepository;
exports.PgBaseRepository = PgBaseRepository = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [pg_database_service_1.PgDatabaseService])
], PgBaseRepository);
//# sourceMappingURL=pg-base-repository.js.map