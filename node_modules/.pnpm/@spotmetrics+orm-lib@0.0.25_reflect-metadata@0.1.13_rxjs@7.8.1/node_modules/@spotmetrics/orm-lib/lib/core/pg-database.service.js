"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgDatabaseService = void 0;
require("dotenv/config");
const crypto_1 = __importDefault(require("crypto"));
const pg_1 = require("pg");
pg_1.types.setTypeParser(1114, function (stringValue) {
    return new Date(stringValue + "+0000");
});
pg_1.types.setTypeParser(1082, function (stringValue) {
    return stringValue;
});
class PgDatabaseService {
    constructor() {
        const connectionString = process.env.DATABASE_URL;
        this.pgClient = new pg_1.Pool({
            connectionString: connectionString,
        });
    }
    buildWhereClause(where, index = 1) {
        let _where = Object.fromEntries(Object.entries(where).filter(([_, v]) => v !== undefined));
        let params = [];
        let query = Object.entries(_where)
            .map(([key, value]) => {
            if (key === "$and" || key === "$or") {
                const subquery = value
                    .map((subWhere) => {
                    const result = this.buildWhereClause(subWhere, params.length + 1);
                    params = params.concat(result.params);
                    return result.query;
                })
                    .join(` ${key.slice(1).toUpperCase()} `);
                return `(${subquery})`;
            }
            else if (value === null) {
                return `${key} IS NULL`;
            }
            else if (typeof value === "object" && "$ne" in value) {
                if (value["$ne"] === null) {
                    return `${key} IS NOT NULL`;
                }
                else {
                    params.push(value["$ne"]);
                    return `${key} != $${index++}`;
                }
            }
            else {
                params.push(value);
                return `${key} = $${index++}`;
            }
        })
            .join(" AND ");
        return { query, params };
    }
    async runQuery(query, where = {}, pool = this.pgClient) {
        const whereResult = this.buildWhereClause(where);
        if (whereResult.query) {
            query += " WHERE " + whereResult.query;
        }
        console.log(query.replace(/^\s+/gm, "").replace(/\n/g, " "));
        console.log(whereResult.params);
        const result = await pool.query(query, whereResult.params);
        return result.rows;
    }
    async runQuerySingle(query, where = {}, pool = this.pgClient) {
        const whereResult = this.buildWhereClause(where);
        if (whereResult.query) {
            query += " WHERE " + whereResult.query;
        }
        query += " LIMIT 1";
        console.log(query.replace(/^\s+/gm, "").replace(/\n/g, " "));
        console.log(whereResult.params);
        const { rows } = await pool.query(query, whereResult.params);
        return rows[0] || null;
    }
    async runTransaction(callback, advisoryLock) {
        const client = await this.pgClient.connect();
        try {
            await this.runQuery("BEGIN", {}, client);
            if (advisoryLock) {
                const lockQuery = `SELECT PG_ADVISORY_XACT_LOCK(HASHTEXT('${crypto_1.default
                    .createHash("sha256")
                    .update(advisoryLock)
                    .digest("hex")}'))`;
                await this.runQuery(lockQuery, {}, client);
            }
            await callback(client, this);
            await this.runQuery("COMMIT", {}, client);
        }
        catch (e) {
            await this.runQuery("ROLLBACK", {}, client);
            throw e;
        }
        finally {
            client.release();
        }
    }
}
exports.PgDatabaseService = PgDatabaseService;
//# sourceMappingURL=pg-database.service.js.map